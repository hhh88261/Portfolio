# 선박위치라이브 서비스  

## 목차
1. 기술 스택    
2. 프로젝트 개요    
3. 프로젝트 소개  
4. 아키텍처   
5. 주요 기능   
6. 리팩토링  
7. 프로젝트 후기  

## 기술 스택
<img src="https://img.shields.io/badge/vue.js-41B883?style=for-the-badge&logo=vue.js&logoColor=white"> : 수백개의 마커가 웹상에 표시되야 했기에 렌더링이 빠른 vue를 선택  
<img src="https://img.shields.io/badge/java-007396?style=for-the-badge&logo=OpenJDK&logoColor=white"> : java.net으로 소켓 통신을 구현하고 maven에서 AIS 메시지를 파싱하는 의존성을 사용하기 위해 채택  
<img src="https://img.shields.io/badge/springboot-6DB33F?style=for-the-badge&logo=springboot&logoColor=white"> : Spring mvc로 api를 구현하기 위해 채택  
![Oracle](https://img.shields.io/badge/Oracle-F80000?style=for-the-badge&logo=oracle&logoColor=white) 

## 프로젝트 개요
- 실시간 선박 추적 프로그램
- 프로젝트 기간 : 2024.09 ~ 2024.12
- 프로젝트 인원 : 1명

## 프로젝트 소개
- 이 프로그램은 AIS(자동식별시스템)를 활용하여 해양에서 운항하고 있는 선박을 추적하거나 항로를 확인할 수 있고 선박의 국적, 속도, 방향 등과 같은 제원정보도 모니터링할 수 있다.

> 백엔드  
> 송신 서버    
https://github.com/hhh88261/AIS-Custom-Server  
> Parsing 서버(파싱 + 수신)      
https://github.com/hhh88261/Marine-vessel-information-Server  
> Spring Boot (REST)  
https://github.com/hhh88261/Vessel-location-information-coastal-AIS-API  

> 프론트엔드(Vue)     
https://github.com/hhh88261/Marine-vessel-information-App


## 프로젝트 아키텍처
![Image](https://github.com/user-attachments/assets/9a21127b-2a39-4f6c-b945-d9cda011596c)
#### 구조
- AIS 신호 송신서버, 수신서버, API 서버, 클라이언트로 구성된다.  
- 사용자 요청은 REST API 기반으로 처리한다.
- JWT 토큰으로 로그인 인증을 관리한다. 
  
#### 흐름
1. 사용자 로그인
2. 파싱서버에 요청 전송
3. 송신서버에서 원시 AIS 메시지를 생성하여 파싱서버로 전송  
4. 파싱서버에서 TCP 소켓을 사용해 데이터를 수신 
5. 데이터 가공 및 DB 저장 후 Web Socket을 통해 클라이언트에게 메시지를 송신  
6. 클라이언트에서 수신받은 데이터를 바탕으로 화면에 선박 위치를 표시

#### 설계 근거  
- 유지보수성, 실시간성, 이식성에 초점을 두어 설계했다.  
- 송신서버는 실제 AIS 서버로 대체될 수 있으므로 송신과 수신 + 파싱 모듈로 분리했다.    
- 파싱서버가 일방적으로 수신하는 형태이기 때문에 양방향 통신이 필요 없으므로 단방향 TCP 통신 방식을 사용했다.      
- 클라이언트는 파싱서버와 지속적인 연결을 해야하기 때문에 WebSocket 통신 방식을 사용했다.
- 인증정보 탈취 위험에 대비하기 위해 JWT를 도입했다. Refresh Token과 Access Token을 분리하여 보안성을 강화했다.


### ERD
![Image](https://github.com/user-attachments/assets/0eb312bf-c9cd-45cb-acd3-949be7af0a5a)

## 주요 기능

### 로그인 기능  
- 아이디와 비밀번호를 입력해 로그인한다.  
- Accounts 테이블에 유저 정보가 있다면 Refresh Token과 Access Token을 발급받는다.  
- 로그인에 성공하면 /Main 으로 이동한다.   
![Image](https://github.com/user-attachments/assets/d79a5ca1-fc32-4937-83b2-43c8aa646326)


### 회원가입 기능  
- 이름, 이메일, 비밀번호를 입력하여 회원가입을 할 수 있다.  
- 유저 정보는 Accounts 테이블에 저장된다.  
- '회원가입' 버튼을 클릭하면 로그인 화면으로 돌아간다.  
![Image](https://github.com/user-attachments/assets/49d80740-ea2c-4063-ae49-8d45cba005d1)

### 추적 기능
- 선박의 위치가 검은색 마커로 표시되며 파란색 선으로 선박의 10분뒤 위치를 예측한다.
- 새로운 위치 정보가 들어올 때 마다 마커의 위치가 변경된다.
![Image](https://github.com/user-attachments/assets/088d9dbf-1b16-4827-9f1d-6a69e13e3a95)

### 검색 기능
- 선박번호(MMSI)를 검색창에 입력 후 검색 버튼을 누르면 선박이 위치한 곳으로 화면을 이동시킨다.
- 마커를 클릭하면 선박에 대한 상세정보를 볼 수 있다.
![Image](https://github.com/user-attachments/assets/186752a2-506e-426f-8f8b-899772e7682d)

### 리플레이 기능
- 날짜, 시간을 입력 후 재생 버튼을 눌러 과거의 선박 경로를 확인할 수 있다.
![Image](https://github.com/user-attachments/assets/03120119-992e-4074-a9aa-b8ab4cfb21a1)


## 리팩토링

단일 책임 원칙 준수 : 한 클래스가 담당하고 있던 여러 기능들을 분리

하드 코딩 제거 : 인터페이스로 추상화 하거나 Mock 개체 주입 가능하게 설계 변경

Async 예외 처리 : 예외가 발생했을 때 시스템은 계속 동작하되 클라이언트에게 에러 발생 메시지 전송

### 인덱스 / 파티셔닝  
가설 :   
현재 과거항적을 저장하는 테이블이 있다. 
하지만 다수의 클라이언트가 한 테이블을 반복적으로 조회하거나 시간이 지나 테이블이 크기가 커질수록 조회 성능이 저하됬다.   
인덱스와 파티셔닝을 활용하면 탐색비용을 줄이고 성능 저하 현상을 개선할 수 있을 것이다.

Case1 : 인덱스, 파티셔닝 미수행  
Case2 : 인덱스, 날짜별 Range 파티셔닝 수행  
Case3 : 인덱스, 테이블 분할 수행  

결과 정리 :  
![Image](https://github.com/user-attachments/assets/84413299-c0e2-485c-99bb-bd81a12ab1a8)

결과 분석 : 
물리적으로 테이블을 분리하고 인덱스를 설정하여 평균 응답시간이 28ms에서 5.2ms로 줄었다.

Case1 : Full Scan이 발생했다.  
Case2 : Start Time과 End Time 간격이 커질 수록 조회 범위가 커졌고 중복되는 날짜, MMSI가 많아 이중 인덱스 스캔이 발생하여 효과적이지 않았다.  
Case3 : 예상보다 성능향상이 크게 이루어졌다. 날짜별로 테이블을 나누어 테이블 크기가 감소했고 그에 따라 불필요한 데이터가 줄어들어 빠른 접근이 가능했기 때문이다. 또한 파티션 프루닝을 위한 내부 처리를 하지 않고 단일 테이블 하나만 접근함으로써 결과가 즉각적으로 나올 수 있었던 것으로 보인다.  

단점 :   
날짜가 지날수록 테이블 수가 늘어남에 따라 디스크에 부하를 줄 수 있다. 1년 간격으로 테이블을 삭제하는 스케줄러를 추가하여 관리하는 방법을 고려할 수 있다.


### BIO vs NIO
가설 :   
현재 디코딩 서버의 데이터 수신 방식은 Polling 방식이다. 
하지만 연결이 늘어나 처리량이 늘어날수록 성능이 저하되는 문제가 발생했다.    
While 수신 방식을 이벤트 기반의 통신방식을 사용하면 이벤트가 발생할 때에만 자원을 사용하므로 이러한 문제점을 개선할 수 있을 것이다.  

Case1 : 초당 1개의 데이터 5분 간 수신  
Case2 : 초당 5개의 데이터 5분 간 수신  
Case3 : 초당 10개의 데이터 5분 간 수신    

결과 정리 :   
![Image](https://github.com/user-attachments/assets/10a1c96e-03f1-4715-8559-b318484daa00)

결과 분석 :   
전체적으로 수신 데이터 양이 늘어날수록 NIO 처리량이 높아지는 경향을 보였다.  
소량의 데이터를 처리할 때는 기존 블로킹 구조가 단순하여 처리가 더 빨랐다.   
하지만 클라이언트 연결이 늘어나 스레드가 증가할수록 다수,고빈도 이벤트 처리에 최적화된 NIO가 더 효율적으로 작동했다.    

고려사항 :  
수신량이 제한된 현재 프로젝트 구조에서는 기존 방식을 유지하는 것이 유리하다.    
다만 실제 AIS 송신 서버와 연결하여 수천개의 데이터를 수신해야 한다면 Java NIO 방식을 채용하는 것이 효율적일 것이다.  

## 프로젝트 후기

### 배운점
- TCP 양방향 통신에 대해 배울 수 있었습니다. AIS 서버가 디코딩 서버에 메시지를 보내고 디코딩 서버가 입력 스트림으로 입력받으면 다시 수신확인 메시지를 보내며 응답하는 방식으로 구현했습니다. 통신이 끝나면 socket.close()로 통신을 종료시키도록 했습니다. 이 기능을 구현하면서 서버와 클라이언트간의 상호작용 방식을 배울 수 있었고, 실시간 데이터 송수신에 왜 TCP 방식이 사용되는지 알 수 있었습니다.
- API 명세서를 작성하는 것에 대해 배울 수 있었습니다. github에 push하면서 '혹시나 다른 사람이 내 api를 본다면 한번에 이해할 수 있을까?'라는 의문점을 가지게되었고 인턴 당시 제 사수님께 코드를 보여드리면서 궁금한 점을 여쭈었습니다. 사수님께서는 단순한 api라도 다른 사용자들 입장에서는 어떤 정보를 어떤 방식으로 요청해야하는지, 어떤 정보를 전달받을 수 있을지, 어떤 형식으로 데이터가 넘어오는지 알 수 없기 때문에 명세서는 꼭 작성해야한다고 당부하셨습니다. 저는 구글링과 다른 github api 저장소를 참고하여 api 명세서를 작성하였고 이 과정을 통해 사용자들의 경험을 개선시킬 수 있는 방법에 대해 생각해볼 수 있었습니다.

### 어려웠던 점
- 메시지를 인코딩, 디코딩하는 과정을 코드로 구현하는 것이 힘들었습니다. 128비트, 424비트라는 긴 길이의 비트를 각 요소별로 나누어 10진수로 변환하는 과정은 많은 시간을 소요했습니다. 특히 타입 5의 메시지가 수신되었을 때 그 직후에 수신되는 메시지까지
이어서 파싱해야한다는 점을 알지 못했었습니다. AIVDM 공식 홈페이지를 통해 이 사실을 알 수 있었고 문제를 해결하였습니다. 
- 오랫동안 정보가 들어오지 않은 마커를 삭제하는 작업이 어려웠습니다. 많은 양의 마커가 웹상에 그려지다 보니 렌더링 성능 저하가 발생했습니다. setTimeout을 활용하여 5분동안 동일한 mmsi가 수신되지 않으면 삭제하는 로직을 구현하였지만
1초당 수신되는 AIS 메시지가 10건에 달했기에, 5분간의 간격으로는 많은 양의 트래픽을 감당하기에는 어려움이 있었습니다. 마커를 그릴 때 feature를 사용하지 않고 canvas layers 등과 같은 방법을 생각했지만 데드라인을 지키지 못해 해결하지 못했습니다. 



